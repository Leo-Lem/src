\documentclass{summary}

\subject{Algorithms and Data Structures}
\semester{Winter 2023/24}
\author{Leopold Lemmermann}

\begin{document}\createtitle

\section{Asymptotic View}
\subsection{Bachmann-Landau Notation}
\begin{itemize}
  \item[$\bigO$] (big O: upper bound) $f\in \bigO(g) \Leftrightarrow ^{\exists c > 0}_{\exists n_0 > 0}: f \leq c \cdot g \forall n > n_0$
  \item[$\Omega$] (big Omega: lower bound) $f\in \Omega(g) \Leftrightarrow ^{\exists c > 0}_{\exists n_0 > 0}: f \geq c \cdot g \forall n > n_0$
  \item[$\littleO$] (little o: strict upper bound) $f\in \littleO(g) \Leftrightarrow ^{\forall c > 0}_{\exists n_0 > 0}: f < c \cdot g \forall n > n_0$
  \item[$\omega$] (little omega: strict lower bound) $f\in \omega(g) \Leftrightarrow ^{\forall c > 0}_{\exists n_0 > 0}: f > c \cdot g \forall n > n_0$
  \item[$\Theta$] (big Theta: tight bound) $f\in \Theta(g) \Leftrightarrow f\in \bigO(g) \land f\in \Omega(g)$
\end{itemize}

\subsection{Master Theorem}
The master theorem is a method for solving recurrences of the form
\begin{equation}
  T(n) = \begin{cases}
    \bigO(1)                                                                                   & \forall n \leq n_0 \\
    \underbrace{aT(\frac{n}{b})}_{\text{recursion}} + \underbrace{f(n)}_{\text{non-recursion}} & \text{else}
  \end{cases}
\end{equation}
where $a \geq 1$, $b > 1$, $f(n)$ is a given function, and $n_0$ is a given constant.

\begin{itemize}
  \item[I.] (recursion dominates) $\exists \epsilon > 0: f(n) \in \bigO(n^{\log_b(a)-\epsilon}) \Rightarrow T(n) \in \Theta(n^{\log_b a})$
  \item[II.] (recursion and non-recursion are balanced) $\exists k \ge 0: f(n) \in \Theta(n^{\log_b a}\log^k n) \Rightarrow T(n) \in \Theta(n^{\log_b a} \log^{k+1} n)$
  \item[III.] (non-recursion dominates) $\underbrace{^{\exists \epsilon > 0: f(n) \in \Omega(n^{\log_b(a)+\epsilon})}_{\exists c \in [0\dots1]: a f(\frac{n}{b}) \leq c f(n)}}_{\text{\tiny regularity condition}} \Rightarrow T(n) \in \Theta(f(n))$
\end{itemize}


\section{Selection}


\section{Red-Black Trees}

\subsection{Properties}
\begin{itemize}
  \item[I.]\label{properties:1} [Colored] Every node is either red or black.
  \item[II.]\label{properties:2} [Black Root] The root is black.
  \item[III.]\label{properties:3} [Black Leafs] Every leaf (NIL) is black.
  \item[IV.]\label{properties:4} [Red $\to$ Black Children] If a red node has children, then the children are black.
  \item[V.]\label{properties:5} [Black Height] For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.
\end{itemize}

\subsection{Insertion}

\begin{algorithm}[H]
  \caption{\texttt{insert(T, x)}}

  \KwData{A red-black tree $T$ and a node $x$}
  \KwResult{A red-black tree $T$ with node $x$}
  \BlankLine

  \comment{find insertion point (and stop at guard/after leaf)}
  $next = T.root$\;
  \Repeat{$next$ is  a leaf}{
    \lIf{$x < next$}{$next \gets next.left$}
    \lElse{$next \gets next.right$}
  }

  \comment{connect $x$ to parent}
  $x.parent \gets next.parent$\;
  \lIf{$x.parent = nil$}{$T.root \gets x$}
  \lElseIf{$x < x.parent$}{$x.parent.left \gets x$}
  \lElse{$x.parent.right \gets x$}

  \comment{fix the properties}
  color $x$ red\;
  \texttt{fixupAfterInsert($T, x$)}\;
\end{algorithm}

\begin{algorithm}[H]
  \caption{\texttt{fixupAfterInsert(T, x)}}

  \KwData{A red-black tree $T$ and a newly inserted node $x$}
  \KwResult{A fixed red-black tree $T$}
  \BlankLine

  \comment*[h]{fix I}\explain*{$x.parent$ is left child in cases 1-3, right child in cases 4-6}
  \While{$x.parent$ is red}{
    \If(\explain*[f]{cases 1 and 4 (only differ in uncle)}){$x.uncle$ is red}{
      color $x.parent$ and $x.uncle$ black\\
      color $x.grandparent$ red\\
      \textbf{continue} with $x \gets x.grandparent$
    }
    \Else(\comment*[h]{if $x.uncle$ is black}){
      \If(\explain*[f]{case 2 $|$ $x$ is left child for case 5}){$x$ is a right child}{
        rotate $x.parent$ left\explain*{rotate right for case 5}
        \textbf{continue} with $x \gets x.parent$
      }
      \Else(\tcp*[h]{if $x$ is left child}\explain*[f]{case 3 $|$ $x$ is right child for case 6 }){
        color $x.parent$ black\\
        color $x.grandparent$ red\\
        rotate $x.grandparent$ right\explain*{for case 6 rotate left}
        \textbf{continue} with $x$
      }
    }
  }

  \comment{fix II}
  color $T.root$ black
\end{algorithm}

\subsection{Deletion}

\begin{algorithm}[H]
  \caption{\texttt{delete(T, x)}}

  \KwData{A red-black tree $T$ and a node $x$}
  \KwResult{A red-black tree $T$ without node $x$}
  \BlankLine

  \comment{swap x with minimum}
  \If{$x$ has two children}{
    $swappee \gets $ minimum$(x.right)$\explain*{alternative: successor(x)}
    $x.key \gets swappee.key$\;
    $x \gets swappee$
  }
  \comment{remove x (or swappee)}
  connect $x.child$ with $x.parent$ ?? $T.root$\explain*{use $T.root$ if $x.parent$ is $nil$}
  \lIf(\explain*[f]{$x$ is red $\to$ no violations}){$x$ is black}{\texttt{fixupAfterDelete($T, x.child$)}}
  \textbf{delete} $x$\;
\end{algorithm}

\begin{algorithm}[H]
  \caption{\texttt{fixupAfterDelete(T, x)}}

  \KwData{A red-black tree $T$ and a node $x$}
  \KwResult{A fixed red-black tree $T$}
  \BlankLine

  \comment*[h]{fix V}\explain*{$x.parent$ is left child in cases 1-4, right child in cases 5-8}
  \While{$x \neq T.root$ \textbf{and} $x$ is black}{
    \If(\explain*[f]{cases 1 and 5 (only differ in sibling)}){$x.sibling$ is red}{
      color $x.sibling$ black\\
      color $x.parent$ red\\
      rotate $x.parent$ left\\
      \textbf{continue} with $x \gets x.sibling$
    }
    \Else(\comment*[h]{if $x.sibling$ is black}){
      \If(\explain*[f]{cases 2 and 6 (only differ in sibling)}){$x.sibling.children$ are black}{
        color $x.sibling$ red\\
        \textbf{continue} with $x \gets x.parent$
      }
      \Else(\comment*[h]{if $x.sibling$ has red child}){
        \If(\explain*[f]{case 3 $|$ $x.sibling.left$ for case 7}){$x.sibling.right$ is black}{
          color $x.sibling.left$ black\explain*{$x.sibling.right$ for case 7}
          color $x.sibling$ red\\
          rotate $x.sibling$ right\explain*{rotate left for case 7}
          \textbf{continue} with $x \gets x.sibling$
        }
        \Else(\comment*[h]{if $x.sibling.left$ is black}\explain*[f]{case 4 $|$ $x.sibling.right$ for case 8}){
          color $x.sibling$ like $x.parent$\\
          color $x.parent$ \textbf{and} $x.sibling.right$ black\explain*{$x.sibling.left$ for case 8}
          rotate $x.parent$ left\explain*{rotate right for case 8}
          \textbf{break} with $x \gets T.root$
        }
      }
    }
  }

  \comment{fix II and IV}
  color $x$ black
\end{algorithm}

\section{Graphs}
\subsection{Topological Sort}
\begin{algorithm}[H]
  \caption{\texttt{topologicalSort(G)}}

  \KwData{A graph $G$}
  \KwResult{A topological sorted list of vertices $L$}
  \BlankLine

  $L \gets \emptyset$\;
  \ForEach{vertex $v$ of $G$}{
    \lIf{$v$ is not visited}{
      \texttt{DFS($v, L$)}
    }
  }
  \Return $L$\;
\end{algorithm}

\begin{algorithm}[H]
  \caption{\texttt{DFS(u, L)}}

  \KwData{A vertex $u$ and a list $L$}
  \BlankLine

  \ForEach{vertex $v$ of $u$'s neighbors}{
    mark $u$ as found\;
    \lIf{$v$ is not visited}{
      \texttt{visit($v$)}
    }
    \lElseIf{$v$ is found}{
      \textbf{error} "cycle detected"
    }
    mark $u$ as visited\;
    $L \gets \{u\} \cup L$\;
  }
\end{algorithm}

\end{document}