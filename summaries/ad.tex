\documentclass{summary}

\subject{Algorithms and Data Structures}
\semester{Winter 2023/24}
\author{Leopold Lemmermann}

\begin{document}\createtitle

\section{Asymptotic View}
\subsection{Bachmann-Landau Notation}
\begin{itemize}
  \item[$\bigO$] (big O: upper bound) $f\in \bigO(g) \Leftrightarrow ^{\exists c > 0}_{\exists n_0 > 0}: f \leq c \cdot g \forall n > n_0$
  \item[$\Omega$] (big Omega: lower bound) $f\in \Omega(g) \Leftrightarrow ^{\exists c > 0}_{\exists n_0 > 0}: f \geq c \cdot g \forall n > n_0$
  \item[$\littleO$] (little o: strict upper bound) $f\in \littleO(g) \Leftrightarrow ^{\forall c > 0}_{\exists n_0 > 0}: f < c \cdot g \forall n > n_0$
  \item[$\omega$] (little omega: strict lower bound) $f\in \omega(g) \Leftrightarrow ^{\forall c > 0}_{\exists n_0 > 0}: f > c \cdot g \forall n > n_0$
  \item[$\Theta$] (big Theta: tight bound) $f\in \Theta(g) \Leftrightarrow f\in \bigO(g) \land f\in \Omega(g)$
\end{itemize}

\subsection{Master Theorem}
The master theorem is a method for solving recurrences of the form
\begin{equation}
  T(n) = \begin{cases}
    \bigO(1)                                                                                   & \forall n \leq n_0 \\
    \underbrace{aT(\frac{n}{b})}_{\text{recursion}} + \underbrace{f(n)}_{\text{non-recursion}} & \text{else}
  \end{cases}
\end{equation}
where $a \geq 1$, $b > 1$, $f(n)$ is a given function, and $n_0$ is a given constant.

\begin{itemize}
  \item[I.] (recursion dominates) $\exists \epsilon > 0: f(n) \in \bigO(n^{\log_b(a)-\epsilon}) \Rightarrow T(n) \in \Theta(n^{\log_b a})$
  \item[II.] (recursion and non-recursion are balanced) $\exists k \ge 0: f(n) \in \Theta(n^{\log_b a}\log^k n) \Rightarrow T(n) \in \Theta(n^{\log_b a} \log^{k+1} n)$
  \item[III.] (non-recursion dominates) $\underbrace{^{\exists \epsilon > 0: f(n) \in \Omega(n^{\log_b(a)+\epsilon})}_{\exists c \in [0\dots1]: a f(\frac{n}{b}) \leq c f(n)}}_{\text{\tiny regularity condition}} \Rightarrow T(n) \in \Theta(f(n))$
\end{itemize}


\section{Selection}

% struct SelectableArray: Array {
%   n = self.size
%   m = 5 // m is the group size (median quantity)

%   // T(n) = T(3/4n) + O(n+m-1) and T(<m) = c => T(n) = O(n) (III. case of the Master Theorem with k=1/(m+1))
%   // r is the wanted rank
%   select(r: Index) -> Element
%     q = self.findMedianOfMedians(r) // q is the pivot index

%     switch q
%     case r do return self[q]
%     case ..<r do return self.partition(q).greater.select(r) // T(3/4n)
%     default do return self.partition(q).lesser.select(r) // T(3/4n)

%   // T(n) = T(n/m) + O(n+m-1) = O(n+m-1) (III. case of the Master Theorem with k=1/(m+1))
%   findMedianOfMedians(r: Index) -> q
%     // O(m-1)
%     while n % m != 0 do
%       if n <= 1 do return 0
%       self.remove(self.minIndex)

%     // O(n)
%     medians = self.findMedians()

%     // T(n/m)
%     return medians.findMedianOfMedians(r)

%   // O(n/m * m) = O(n)
%   findMedians() -> Array
%     g = n / m // g is the group quantity
%     medians = []
%     for i in 0..<g do
%       medians.append(findMedianWithStride(i))

%     return medians

%   // O(m)
%   findMedianWithStride(I:Index) -> Element
%     slice = []
%     for j in 0..<m do
%       slice.append(self[i * m + j])
%     return slice.sorted()[m / 2]

%   // O(n)
%   partition(q: Index) -> (lesser: Array, : greater: Array)
%     lesser = [], greater = []
%     pivot = self[q]

%     for i in 0..<self.size do
%       if self[i] â‰¤ pivot do lesser.append(self[i])
%       else do greater.append(self[i])

%     return (lesser, greater)
% }


\section{Red-Black Trees}

\subsection{Properties}
\begin{itemize}
  \item[I.]\label{properties:1} [Colored] Every node is either red or black.
  \item[II.]\label{properties:2} [Black Root] The root is black.
  \item[III.]\label{properties:3} [Black Leafs] Every leaf (NIL) is black.
  \item[IV.]\label{properties:4} [Red $\to$ Black Children] If a red node has children, then the children are black.
  \item[V.]\label{properties:5} [Black Height] For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.
\end{itemize}

\subsection{Insertion}

\begin{algorithm}[H]
  \caption{\texttt{insert(T, x)}}

  \KwData{A red-black tree $T$ and a node $x$}
  \KwResult{A red-black tree $T$ with node $x$}
  \BlankLine

  \comment{find insertion point (and stop at guard/after leaf)}
  $next = T.root$\;
  \Repeat{$next$ is  a leaf}{
    \lIf{$x < next$}{$next \gets next.left$}
    \lElse{$next \gets next.right$}
  }

  \comment{connect $x$ to parent}
  $x.parent \gets next.parent$\;
  \lIf{$x.parent = nil$}{$T.root \gets x$}
  \lElseIf{$x < x.parent$}{$x.parent.left \gets x$}
  \lElse{$x.parent.right \gets x$}

  \comment{fix the properties}
  color $x$ red\;
  \texttt{fixupAfterInsert($T, x$)}\;
\end{algorithm}

\begin{algorithm}[H]
  \caption{\texttt{fixupAfterInsert(T, x)}}

  \KwData{A red-black tree $T$ and a newly inserted node $x$}
  \KwResult{A fixed red-black tree $T$}
  \BlankLine

  \comment*[h]{fix I}\explain*{$x.parent$ is left child in cases 1-3, right child in cases 4-6}
  \While{$x.parent$ is red}{
    \If(\explain*[f]{cases 1 and 4 (only differ in uncle)}){$x.uncle$ is red}{
      color $x.parent$ and $x.uncle$ black\\
      color $x.grandparent$ red\\
      \textbf{continue} with $x \gets x.grandparent$
    }
    \Else(\comment*[h]{if $x.uncle$ is black}){
      \If(\explain*[f]{case 2 $|$ $x$ is left child for case 5}){$x$ is a right child}{
        rotate $x.parent$ left\explain*{rotate right for case 5}
        \textbf{continue} with $x \gets x.parent$
      }
      \Else(\tcp*[h]{if $x$ is left child}\explain*[f]{case 3 $|$ $x$ is right child for case 6 }){
        color $x.parent$ black\\
        color $x.grandparent$ red\\
        rotate $x.grandparent$ right\explain*{for case 6 rotate left}
        \textbf{continue} with $x$
      }
    }
  }

  \comment{fix II}
  color $T.root$ black
\end{algorithm}

\subsection{Deletion}

\begin{algorithm}[H]
  \caption{\texttt{delete(T, x)}}

  \KwData{A red-black tree $T$ and a node $x$}
  \KwResult{A red-black tree $T$ without node $x$}
  \BlankLine

  \comment{swap x with minimum}
  \If{$x$ has two children}{
    $swappee \gets $ minimum$(x.right)$\explain*{alternative: successor(x)}
    $x.key \gets swappee.key$\;
    $x \gets swappee$
  }
  \comment{remove x (or swappee)}
  connect $x.child$ with $x.parent$ ?? $T.root$\explain*{use $T.root$ if $x.parent$ is $nil$}
  \lIf(\explain*[f]{$x$ is red $\to$ no violations}){$x$ is black}{\texttt{fixupAfterDelete($T, x.child$)}}
  \textbf{delete} $x$\;
\end{algorithm}

\begin{algorithm}[H]
  \caption{\texttt{fixupAfterDelete(T, x)}}

  \KwData{A red-black tree $T$ and a node $x$}
  \KwResult{A fixed red-black tree $T$}
  \BlankLine

  \comment*[h]{fix V}\explain*{$x.parent$ is left child in cases 1-4, right child in cases 5-8}
  \While{$x \neq T.root$ \textbf{and} $x$ is black}{
    \If(\explain*[f]{cases 1 and 5 (only differ in sibling)}){$x.sibling$ is red}{
      color $x.sibling$ black\\
      color $x.parent$ red\\
      rotate $x.parent$ left\\
      \textbf{continue} with $x \gets x.sibling$
    }
    \Else(\comment*[h]{if $x.sibling$ is black}){
      \If(\explain*[f]{cases 2 and 6 (only differ in sibling)}){$x.sibling.children$ are black}{
        color $x.sibling$ red\\
        \textbf{continue} with $x \gets x.parent$
      }
      \Else(\comment*[h]{if $x.sibling$ has red child}){
        \If(\explain*[f]{case 3 $|$ $x.sibling.left$ for case 7}){$x.sibling.right$ is black}{
          color $x.sibling.left$ black\explain*{$x.sibling.right$ for case 7}
          color $x.sibling$ red\\
          rotate $x.sibling$ right\explain*{rotate left for case 7}
          \textbf{continue} with $x \gets x.sibling$
        }
        \Else(\comment*[h]{if $x.sibling.left$ is black}\explain*[f]{case 4 $|$ $x.sibling.right$ for case 8}){
          color $x.sibling$ like $x.parent$\\
          color $x.parent$ \textbf{and} $x.sibling.right$ black\explain*{$x.sibling.left$ for case 8}
          rotate $x.parent$ left\explain*{rotate right for case 8}
          \textbf{break} with $x \gets T.root$
        }
      }
    }
  }

  \comment{fix II and IV}
  color $x$ black
\end{algorithm}

\section{Graphs}
\subsection{Topological Sort}
\begin{algorithm}[H]
  \caption{\texttt{topologicalSort(G)}}

  \KwData{A graph $G$}
  \KwResult{A topological sorted list of vertices $L$}
  \BlankLine

  $L \gets \emptyset$\;
  \ForEach{vertex $u$ of $G$}{
    \lIf{$u$ is not visited}{
      \texttt{dfs($u, L$)}
    }
  }
  \Return $L$\;
\end{algorithm}

\begin{algorithm}[H]
  \caption{\texttt{dfs(u, L)}}

  \KwData{A vertex $u$ and a list $L$}
  \BlankLine

  mark $u$ as found\;
  \ForEach{vertex $v$ of $u$'s neighbors}{
    \lIf{$v$ is not visited}{
      \texttt{dfs($v$)}
    }
    \lElseIf{$v$ is found}{
      \textbf{error} "cycle detected"
    }
  }
  mark $u$ as visited\;
  $L \gets \{u\} \cup L$
\end{algorithm}

\subsection{Strongly Connected Components: Kosaraju-Sharir's Algorithm}
\begin{algorithm}[H]
  \caption{\texttt{findSCCs(G)}}

  \KwData{A graph $G$}
  \KwResult{A list of strongly connected components $SCCs$}
  \BlankLine

  $L \gets \emptyset$\explain*{$L$ is a list to allow backtracking}
  \ForEach{vertex $u$ of $G$}{
    \lIf{$u$ is not visited}{\texttt{dfs($G, u, L$)}}
  }

  \BlankLine
  invert edges of $G$ and reset visited flags\;
  \BlankLine

  $SCCs \gets \emptyset$\;
  \ForEach{vertex $u\in L$ in reverse order}{
    \lIf{$u$ is not visited}{
      $scc \gets \emptyset$\;
      \texttt{dfs($G, u, scc$)}\explain*{$scc$ is used in place of $L$ to collect the vertices of the SCC}
      $SCCs \gets SCCs \cup \{scc\}$
    }
  }
  \Return $SCCs$\;
\end{algorithm}

\begin{algorithm}[H]
  \caption{\texttt{dfs($G, u, L$)}}

  \KwData{A graph $G$, a vertex $u$, and a list $L$}
  \BlankLine

  mark $u$ as found\;
  \ForEach{vertex $v$ of $u$'s neighbors}{
    \lIf{$v$ is not found}{\texttt{dfs($v$)}}
  }
  mark $u$ as visited\;
  $L \gets L \cup \{u\}$
\end{algorithm}

\subsection{Minimal Spanning Trees}
\begin{algorithm}[H]
  \caption{\texttt{kruskal(G)}}

  \KwData{A graph $G$}
  \KwResult{A minimal spanning tree $T$}
  \BlankLine

  $T \gets \emptyset$\;
  \lForEach(\explain*[f]{interpret $V$ as forest of trees, each connected by $E$}){vertex $v$ of $G$}{
    \texttt{makeSet($v$)}
  }
  sort edges of $G$ by weight\;
  \ForEach{edge $(u, v)$ of $G$}{
    \If{\texttt{findSet($u$)} $\neq$ \texttt{findSet($v$)}}{
      $T \gets T \cup \{(u, v)\}$\;
      \texttt{union($u, v$)}
    }
  }
  \Return $T$\;
\end{algorithm}

% Prim's Algorithm
\begin{algorithm}[H]
  \caption{\texttt{prim($G, w, r$)}}

  \KwData{A graph $G$ with weights $w$, and a root vertex $r$}
  \KwResult{A minimal spanning tree $T$}
  \BlankLine

  $T \gets \emptyset$\;
  $Q \gets G.V$ with $\infty$ priorities\explain*{$Q$ is a (min-)priority queue}
  $r.priority \gets 0$\;
  \While{$Q$ is not empty}{
    $u \gets \texttt{extractMin(Q)}$\;
    \ForEach{vertex $v$ of $u$'s neighbors}{
      \If{$v \in Q$ \textbf{and} $w(u, v) < v.priority$}{
        $v.priority \gets w(u, v)$\;
        $T \gets T \cup \{(u, v)\}$
      }
    }
  }
  \Return $T$\;
\end{algorithm}

\subsection{Shortest Path: Dijkstra's Algorithm}


\end{document}