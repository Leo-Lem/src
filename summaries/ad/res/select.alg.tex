
% struct SelectableArray: Array {
%   n = self.size
%   m = 5 // m is the group size (median quantity)

%   // T(n) = T(3/4n) + O(n+m-1) and T(<m) = c => T(n) = O(n) (III. case of the Master Theorem with k=1/(m+1))
%   // r is the wanted rank
%   select(r: Index) -> Element
%     q = self.findMedianOfMedians(r) // q is the pivot index

%     switch q
%     case r do return self[q]
%     case ..<r do return self.partition(q).greater.select(r) // T(3/4n)
%     default do return self.partition(q).lesser.select(r) // T(3/4n)

%   // T(n) = T(n/m) + O(n+m-1) = O(n+m-1) (III. case of the Master Theorem with k=1/(m+1))
%   findMedianOfMedians(r: Index) -> q
%     // O(m-1)
%     while n % m != 0 do
%       if n <= 1 do return 0
%       self.remove(self.minIndex)

%     // O(n)
%     medians = self.findMedians()

%     // T(n/m)
%     return medians.findMedianOfMedians(r)

%   // O(n/m * m) = O(n)
%   findMedians() -> Array
%     g = n / m // g is the group quantity
%     medians = []
%     for i in 0..<g do
%       medians.append(findMedianWithStride(i))

%     return medians

%   // O(m)
%   findMedianWithStride(I:Index) -> Element
%     slice = []
%     for j in 0..<m do
%       slice.append(self[i * m + j])
%     return slice.sorted()[m / 2]

%   // O(n)
%   partition(q: Index) -> (lesser: Array, : greater: Array)
%     lesser = [], greater = []
%     pivot = self[q]

%     for i in 0..<self.size do
%       if self[i] â‰¤ pivot do lesser.append(self[i])
%       else do greater.append(self[i])

%     return (lesser, greater)
% }