\documentclass{article}

\usepackage[solutions]{xrcise}

\begin{document}
\sheet[2023]{Probeklausur (100P)}
\begin{exercise}{Cross section (40P)}
  \begin{enumerate}
    \item Sortieren Sie die folgenden Funktionen in aufsteigender Reihenfolge asymptotischen Wachstums:\hfill 4P\[
            25n^2,\quad 10^{12},\quad {1.01}^n,\quad \frac{\sqrt{n}^{2.024}}{\log n},\quad n + \sqrt{n},\quad 2^n,\quad n^{\sqrt{n}}
          \]
    \item Bestimmen Sie eine möglichst scharfe obere Laufzeitschranke für die folgende Rekursion in O-Notation mit Hilfe des Mastertheorems:\hfill{4P}\[
            T(n) =\begin{cases}
              1                                 & \text{falls } n \leq 1, \\
              8T\left(\frac{n}{2}\right) + n +6 & \text{sonst}
            \end{cases}
          \]
    \item Beschreiben Sie kurz in eigenen Worten: Was unterscheidet Hashing mit Verkettung von offener Adressierung?\hfill 4P
    \item Im Problem 5-Clique ist ein ungerichteter Graph G gegeben. Es soll entschieden werden, ob G eine Clique mit 5 Knoten enthält. Gibt es einen Algorithmus, der 5-Clique in polynomieller Zeit löst? Begründen Sie kurz.\hfill 4P
    \item Wenden Sie den Bellman-Ford-Algorithmus auf den folgenden Graphen startend von Knoten $a$ an und geben Sie für jeden Durchlauf der äußeren Schleife die Vorgängerknoten und Distanzen an.\hfill 4P
          \input{res/bellmanford.fig}
    \item Wenden Sie den MergeSort-Algorithmus auf das folgende Array an. Geben Sie das Array nach jeder Merge-Operation an.\hfill 4P\[
            [15,6,11,31]
          \]
    \item Zeigen oder widerlegen Sie kurz: Jeder AVL-Baum mit $n$ Knoten hat mindestens Höhe $n/3$.\hfill 4P
    \item Geben Sie für den folgenden Algorithmus an, wie viele Iterationen die innere Schleife in der $k$-ten Iteration der äußeren Schleife durchläuft ($k \in \mathbb{N}$). Geben Sie möglichst scharfe obere Laufzeitschranke für \texttt{Alg} in O-Notation an.\hfill 4P\par
          \input{res/alg1.alg}
    \item Beim VertexCover-Problem ist ein ungerichteter Graph $G = (V,E)$ gegeben und es soll eine Knotenauswahl $C \subseteq V$ gefunden werden mit $e \cap C \neq \emptyset$ für alle $e \in E$. Dabei soll $|C|$ minimiert werden. Welche der folgenden Aussagen sind korrekt?\hfill 4P
          \hint{Es können 0-4 Antworten richtig sein und es müssen 4 Kreuze gesetzt werden.}
          \begin{itemize}
            \item[$\square$] Eine 2-Approximation für VertexCover findet garantiert eine Lösung, die um maximal 2 Knoten größer als eine optimale Lösung ist
            \item[$\square$] Es gibt eine 2-Approximation für VertexCover
            \item[$\square$] Es gibt ein exaktes Verfahren für VertexCover mit exponentieller Laufzeit
            \item[$\square$] Wenn der Eingabegraph keine Kanten enthält oder ein Pfad ist, kann eine optimale Lösung in polynomieller Zeit gefunden werden
          \end{itemize}
    \item Welche der folgenden Aussagen sind korrekt?\hfill 4P
          \hint{Es können 0-4 Antworten richtig sein und es müssen 4 Kreuze gesetzt werden.}
          \begin{itemize}
            \item[$\square$] Bubblesort hat eine Laufzeit von $O(n^3)$
            \item[$\square$] In einem ungerichteten kantengewichteten Graphen ist der minimale Spannbaum eindeutig
            \item[$\square$] In einem Rot-Schwarz-Baum mit mindestens 10 Knoten gibt es immer mindestens 2 rote Knoten
            \item[$\square$] Man kann die Union-Find-Datenstruktur so implementieren, dass die drei Operationen \texttt{Make-Set}, \texttt{Union} und \texttt{Find-Set} alle Laufzeit $O(1)$ haben.
          \end{itemize}
  \end{enumerate}
  \begin{solution}
    \begin{enumerate}
      \item $10^{12} < n + \sqrt{n} < \frac{\sqrt{n}^{2.024}}{\log n} < 25n^2 < n^{\sqrt{n}} < {1.01}^n < 2^n$
      \item $T(n) = 8T\left(\frac{n}{2}\right) + n +6$ ist Fall I des Mastertheorems mit $a = 8$, $b = 2$ und $f(n) = n + 6$.\par
            Da $f(n) \in \bigO(n^{\log_2 8 - \varepsilon})$ für $\varepsilon = 1$ ist, gilt $T(n) = \Theta(n^{\log_2 8}) = \Theta(n^3)$.
      \item Bei Hashing mit Verkettung wird in jedem Eintrag in der Hashtable eine Liste von Elementen gespeichert, während bei offener Adressierung bei Kollision sondiert wird (z.B. linear oder quadratisch).
      \item 5-Clique ist in polynomieller Zeit lösbar, da jede von 5 Knoten in $n(n-1)(n-2)(n-3)(n-4)\in \bigO(n^5)$ Zeit überprüft werden kann. k-Clique ist lediglich NP-vollständig, wenn $k$ Teil des Inputs ist.
      \item \begin{itemize}
              \item \texttt{a: (0, nil), b: ($\infty$, nil), c: ($\infty$, nil)}\par
              \item \texttt{a: (0, nil), b: (1, a), c: (3,a)}\par
              \item \texttt{a: (0, nil), b: (1, a), c: (-1,b)}
            \end{itemize}
      \item \begin{itemize}
              \item \texttt{merge([6], [15]): [6,15,11,31]}
              \item \texttt{merge([11], [31]): [6,15,11,31]}
              \item \texttt{merge([6,15], [11,31]): [6,11,15,31]}
            \end{itemize}
      \item Nein, ein AVL-Baum mit $n$ Knoten kann Höhe $\log_2 n$ haben, was bereits bei $n = 8$ kleiner als $n/3$ ist.
      \item \begin{itemize}
              \item $k$-te Iteration: $2^k$
              \item Laufzeit: $\bigO(n)$, exponentiell in Eingabe $k$
            \end{itemize}
      \item \begin{itemize}
              \item[\xmark] Eine 2-Approximation garantiert ein Ergebnis, sodass $|C|/|C^*| \leq 2$.
              \item[\checkmark] In der Vorlesung vorgestellt.
              \item[\checkmark] Um \textproblem{vertexcover} in exponentieller Laufzeit zu lösen, kann jede zB. jede Teilmenge von $V$ durchprobiert werden.
              \item[\checkmark] Wenn der Eingabegraph keine Kanten enthält, ist die Lösung trivial. Wenn der Eingabegraph ein Pfad ist, kann das maximale VertexCover 3 Knoten umfassen (da sonst nicht alle verbunden sind). Das lässt sich ebenfalls in polynomieller Zeit überprüfen (Pfad ablaufen).
            \end{itemize}
      \item \begin{itemize}
              \item[\checkmark] Bubblesort hat eine scharfe Laufzeit von $\bigO(n^2)$. $\bigO(n^3)$ ist natürlich trotzdem richtig.
              \item[\xmark] Da gleiche Kantengewichte erlaubt sind, ist der minimale Spannbaum nicht eindeutig.
              \item[\xmark] Ein RB-Baum mit 15 Knoten kann zB. null rote Knoten haben.
              \item[\xmark] Die Operationen \texttt{Make-Set}, \texttt{Union} und \texttt{Find-Set} können höchstens amortisiert in konstanter Zeit ausgeführt werden.
            \end{itemize}
    \end{enumerate}
  \end{solution}
\end{exercise}

\begin{exercise}{Who Am I? (15P)}
  \input{res/whoami.alg}
  \begin{enumerate}
    \item Betrachten Sie eine Ausführung von \textalgo{WhoAmI} für das Eingabearray $A = [7,3,5,3,1,6]$. Welche Werte nimmt $x$ nach jedem Schleifendurchlauf an?\hfill 2P
    \item Welche Ausgabe liefert \textalgo{WhoAmI} für ein gegebenes Array $A$ von $n \geq 1$ natürlichen Zahlen?\hfill 4P
    \item Geben Sie eine geeignete Schleifeninvariante für die Schleife in \textalgo{WhoAmI} an.\hfill 7P
    \item Geben Sie eine möglichst scharfe Schranke für die Laufzeit von \textalgo{WhoAmI} an.\hfill 2P
  \end{enumerate}
  \begin{solution}
    \begin{enumerate}
      \item \begin{tabular}{c|cccccc}
              $i$ & \xmark & 2 & 3 & 4 & 5 & 6 \\
              \hline
              $m$ & 1      & 2 & 1 & 2 & 3 & 1 \\
              $x$ & 1      & 2 & 2 & 2 & 3 & 3
            \end{tabular}
      \item Die Länge der längsten (streng) absteigenden Teilfolge von $A$.
      \item $x$ ist die Länge der längsten (streng) absteigenden Teilfolge von $A[0..i]$.
      \item Die Laufzeit von \textalgo{WhoAmI} ist in $\bigO(n)$, da die Schleife $n-1$-mal durchlaufen wird.
    \end{enumerate}
  \end{solution}
\end{exercise}

\begin{exercise}{Algorithmenentwurf (15P)}
  Wir betrachten Mengen $M \subset \mathbb{N}$ und Lösungen $l_M$ für ein Problem über solchen Mengen. Sei weiter \texttt{Alg} ein Algorithmus, der als Eingabe Folgendes erhält:
  \begin{itemize}
    \item eine Menge $M \subset \mathbb{N}$
    \item eine Teilmenge $S \subseteq M$
    \item Lösungen $l_S, l_{M \setminus S}$ für Teilmengen $S$ und $M \setminus S$
  \end{itemize}
  Der Algorithmus produziert in Zeit $O(|M|^2)$ die Lösung für $M$. Seien dazu Lösungen $l_m$ für alle $m \in M$ gegeben.
  \begin{enumerate}
    \item Gegeben sei die Menge $M = \{1, 2, 3, 4\}$. Geben Sie eine Sequenz an Aufrufen von \texttt{Alg} mit entsprechenden Eingaben an, um die Lösung für $M$ zu konstruieren.\hfill 2P
    \item Konstruieren Sie einen Algorithmus, der \texttt{Alg} nutzt, um eine Lösung für eine beliebige Menge $M \subset \mathbb{N}$ zu produzieren. Für die volle Punktzahl sollte Ihr Algorithmus die Laufzeitschranke von $O(|M|^2)$ einhalten.\hfill 8P
    \item Zeigen Sie die Laufzeit Ihres Algorithmus.\hfill 5P
  \end{enumerate}
  \begin{solution}
    \begin{enumerate}
      \item \begin{itemize}
              \item $l_{\{1,2\}}\gets$\textalgo{Alg($\{1,2\},\{1\},l_1,l_2$)}
              \item $l_{\{3,4\}}\gets$\textalgo{Alg($\{3,4\},\{3\},l_3,l_4$)}
              \item $l_{M}\gets$\textalgo{Alg($M,\{1,2\},l_{\{1,2\}},l_{\{3,4\}}$)}
            \end{itemize}
      \item Der Algorithmus \textalgo{solvesets} ist ein rekursiver Ansatz, welcher die Menge $M$ hälftig auswertet und die Lösungen dann mittels \texttt{Alg} zusammenführt.\par
            \input{res/solvesets.alg}
      \item Die Laufzeit von \textalgo{solvesets} ist $T(M)=2T(M/2)+O(M^2)$, also $T(n) \in \Theta(M^2)$ gem. Mastertheorem Fall III.
    \end{enumerate}
  \end{solution}
\end{exercise}

\begin{exercise}{Algorithmenentwurf II (15P)}
  Gegeben seien zwei Arrays $A$ und $B$ mit $|A| \leq |B|$ und $|A|^3 \geq |B|$, die jeweils paarweise verschiedene ganze Zahlen enthalten. Gesucht ist eine Liste $L$, welche alle Zahlen enthält die in $A$ oder $B$ enthalten sind, bis auf die, die in $A$ und $B$ enthalten sind.\par
  Für gegebene Arrays $A = [3,1,46]$ und $B = [46,1,22,15]$ wären also $[3,22,15]$ oder $[22, 15, 3]$ korrekte Ausgaben (die Sortierung ist nicht vorgegeben), nicht aber $[3, 1, 22, 15]$.
  \begin{enumerate}
    \item Beschreiben Sie kurz einen einfachen Algorithmus mit Laufzeit $O(|A| \cdot |B|)$ für das Problem und begründen Sie kurz die Korrektheit und Laufzeit von Ihrem Ansatz.\hfill 3P
    \item Konstruieren Sie einen Algorithmus mit besserer asymptotischer Laufzeit. Die erreichbare Punktzahl hängt von der Laufzeit des Algorithmus ab (Laufzeiten von $O(|B| \log(|B|))$ oder sogar $O(|B| \log(|A|))$ sind z.B. erreichbar).\hfill 8P
    \item Zeigen Sie die Korrektheit und Laufzeit Ihres Algorithmus aus 2.\hfill 4P
  \end{enumerate}
  \begin{solution}
    \begin{enumerate}
      \item Der Algorithmus iteriert über alle Elemente in $A$ und prüft, ob sie in $B$ enthalten sind. Die Laufzeit ist $O(|A| \cdot |B|)$.
      \item Eine optimale Laufzeit von $\bigO(|A| \log |B|)$ kann folgendermaßen erreicht werden:
            \begin{itemize}
              \item Sortiere $A$ in $\bigO(|A| \log |A|)$ (zB. \textalgo{mergesort})
              \item Iteriere über $B$ und suche jedes Element in $A$ in $\bigO(|B| \log |A|)$: Falls nicht enthalten, füge zu L hinzu. Sonst entferne Element aus $A$.
            \end{itemize}
      \item Wenn sortieren und suchen als korrekt angenommen wird, ist die Korrektheit des Algorithmus offensichtlich. Falls ein Duplikat in $A$ und $B$ gefunden wird, wird es nicht in $L$ aufgenommen. Die Laufzeit des Algorithmus ist $\bigO(|B| \log |A|)$.
    \end{enumerate}
  \end{solution}
\end{exercise}

\begin{exercise}{NP-Vollständigkeit (15P)}
  Das Entscheidungsproblem \textproblem{independent set} entscheidet für einen ungerichteten Graphen $G = (V,E)$ und eine Zahl $k \in \{1,...,|V|\}$ ob ein \texttt{INDEPENDENT SET} der Größe $k$ in $G$ enthalten ist. Ein \textproblem{independent set} der Größe $k$ ist eine Menge $V' \subseteq V$ von Knoten mit $|V'| = k$ und der Eigenschaft, dass kein Knotenpaar in $V'$ mit Kanten verbunden ist (also $\{u, v\} \not\in E$ für alle $u, v \in V'$).\par
  Das Entscheidungsproblem \textproblem{no cuts} entscheidet für eine Menge von Intervallen $S = \{I_1,I_2,I_3,...\}$ und eine Zahl $k \in \{1,...,|S|\}$ ob es eine Teilmenge $T \subseteq S$ mit $|T| \geq k$ gibt, so dass alle Intervalle in $T$ paarweise disjunkt sind.
  \hint{Sie dürfen zur Lösung der folgenden Aufgaben benutzen, dass \textproblem{independent set} NP-schwer ist.}
  \begin{enumerate}
    \item Zeigen Sie das \textproblem{independent set} NP-vollständig ist.\hfill 4P
    \item Zeigen Sie \textproblem{no cuts} $\leq_p$ \textproblem{independent set}.\hfill 8P
    \item Was folgt daraus für die Komplexität von \textproblem{no cuts}?\hfill 3P
  \end{enumerate}
  \begin{solution}
    \begin{enumerate}
      \item Es ist zu zeigen, dass \textproblem{independent set} in NP ist. Eine Lösung lässt sich in polynomieller Zeit verifizieren, indem für jeden Knoten in der Lösung geprüft wird, ob er mit keinem anderen Knoten in der Lösung verbunden ist (Laufzeit $\bigO(|V|^2)$). Somit ist \textproblem{independent set} NP-vollständig (da NP-schwer und in NP).
      \item Für eine Reduktion könnten Intervalle als Knoten abgebildet werden und sich überschneidende Intervalle mit Kanten verbunden werden. Die Zahl $k$ bleibt gleich. Die Reduktion ist in polynomieller Zeit möglich (Laufzeit beschränkt durch $\bigO(S^2)$). Somit ist \textproblem{no cuts} $\leq_p$ \textproblem{independent set}.\par
            In einer Lösung für \textproblem{independent set} sind die Knoten nicht mit Kanten verbunden. Daher sind die Intervalle in einer Lösung für \textproblem{no cuts} paarweise disjunkt (da die Kanten als Überschneidungen interpretiert werden).\par
            In einer Lösung für \textproblem{no cuts} sind die Intervalle paarweise disjunkt. Annahmegemäß wären die repräsentativen Knoten also nicht verbunden.\par
            Somit ist die Reduktion korrekt.
      \item Wir haben lediglich \textproblem{no cuts} auf \textproblem{independent set} reduziert, was keine Aussage über die Komplexität von \textproblem{no cuts} macht. Um eine Aussage über die Komplexität von \textproblem{no cuts} zu machen, müsste \textproblem{independent set} auf \textproblem{no cuts} reduziert werden.
    \end{enumerate}
  \end{solution}
\end{exercise}
\end{document}