\documentclass{article}

\usepackage[solutions]{xrcise}

\begin{document}
\sheet[2020]{Ersttermin}
\begin{exercise}{Laufzeitkomplexität}
  Geben Sie für folgenden Probleme die asymptotische worst-case Laufzeitkomplexität in O-Notation an und begründen Sie diese jeweils knapp.
  \hint{Die Arrays enthalten jeweils keine Duplikate.}
  \begin{enumerate}
    \item Das kleinste Element in einem unsortierten Array finden.
    \item Ein Element in einem unsortierten Array finden, das nicht das kleinste ist.
    \item Das kleinste Element in einem sortierten Array finden.
    \item Aus einem sortierten Array einen balancierten binären Suchbaum konstruieren.
    \item Nennen Sie mindestens 3 Gründe, warum ein Algorithmus $f$ einer niedrigeren Komplexitätsklasse (zum Beispiel $\bigO(n \log n)$) weniger geeignet sein kann als ein Algorithmus $f$ einer höheren Komplexitätsklasse (zum Beispiel $\bigO(n^2)$).
          \hint{Maximal 2 Bonuspunkte für mehr als 3 gute Gründe.}
  \end{enumerate}
\end{exercise}

\begin{exercise}{O-Notation}
  \begin{enumerate}
    \item Geben Sie für folgenden Funktionen möglichst einfache und scharfe O-, $\Omega$- und ggf. $\Theta$-Klassen an.
          \begin{align*}
            f(n) & = 1.5n + n^2                                     \\
            g(n) & = (-1)^3 \log n - \sqrt{n^5} + \log n + \sqrt{n}
          \end{align*}
    \item Ordnen Sie $5n^2, 28, \sqrt{n}, \log n, n^2, (n \log n)^2, 2\sqrt{n}, n!, n^3$ gemäß asymptotischem Wachstum. Begründen Sie Ihre Antwort.
    \item Ist $(\log n)n^2 \in \bigO(n^2)$? Begründen Sie Ihre Antwort.
    \item Berechnen Sie eine scharfe asymptotische Schranke für die Rekurrenzgleichung $T(n) = 4T(n/2) + n$ mit $T(1) = 1$. Geben Sie den Lösungsweg an.
  \end{enumerate}
\end{exercise}

\begin{exercise}{Algorithmenanalyse}
  Analysieren Sie den angegebenen Pseudocode zur Sortierung der Liste $A$ durch den Aufruf SOMESORT($A, 0, A.\text{length}$):
  \begin{algorithm}[ht]
    \caption{SOMESORT($A, i, j$)}
    \KwData{$A[i], i = 1, 2, \ldots, n, A[i] \in \mathbb{N}$}
    \KwResult{$\text{result} \in \mathbb{N}_{>0}$}
    \If{$i \geq j$}{
      \Return
    }
    $m \gets \lfloor (i+j)/2 \rfloor$ \\
    SOMESORT($A, i, m$) \\
    SOMESORT($A, m+1, j$) \\
    \If{$A[j] \leq A[m]$}{
      \text{swap} $A[j]$ and $A[m]$
    }
    SOMESORT($A, i, j-1$)
  \end{algorithm}
  \begin{enumerate}
    \item Beschreiben Sie, wie der Algorithmus sortiert.
    \item Beweisen Sie die Korrektheit des Algorithmus (z.B. mittels Induktion).
    \item Stellen Sie die Rekurrenzgleichung auf und erläutern Sie, warum sich das Master-Theorem nicht anwenden lässt.
    \item Die ersten fünf Zeilen des Algorithmus entsprechen einem aus der Vorlesung bekannten Sortieralgorithmus. Welchem? Warum ist der hier gezeigte Algorithmus viel weniger effizient als der aus der Vorlesung bekannte?
    \item Was bedeutet 'Stabilität' eines Sortierverfahrens? Ist SOMESORT stabil und begründen Sie Ihre Antwort.
  \end{enumerate}
\end{exercise}

\begin{exercise}{Graphen}
  Gegeben ist folgender ungerichteter, kantengewichteter Graph:
  \begin{align*}
    G & = (V, E)                                                                                                           \\
    V & = \{a, b, c, d, e, f, g, h\}                                                                                       \\
    E & = \{(a, b, 2), (a, c, 1), (a, d, 6), (b, c, 6), (b, e, 4), (b, e, 6), (b, f, 6), (c, d, 5), (c, f, 3), (c, g, 7)\}
  \end{align*}
  \begin{enumerate}
    \item Zeichnen Sie den Graphen (leserlich!).
    \item Nennen Sie die Definitionen für den minimalen Spannbaum (MST).
    \item Erklären Sie die Vorgehensweise des PRIMschen Algorithmus und bestimmen Sie damit den oben gegebenen Graphen.
    \item Gegeben sei ein Graph $G$, ein zugehöriger Spannbaum $S$ und eine Kante $e$ im Spannbaum. Sei $G' = (V, E')$ mit $E' = E \setminus \{e\}$. Geben Sie einen effizienten Algorithmus an, welcher einen MST für $G'$ auf Basis von $S$ bestimmt.
    \item Beweisen Sie: Eine Kante $e$ in einem zusammenhängenden Graphen $G$ ist genau dann eine Brückenkante, wenn $e$ in jedem $ST$ von $G$ enthalten ist.
  \end{enumerate}
\end{exercise}

\begin{exercise}{Datenstrukturen}
  Gegeben sei folgende Hashtabelle $T$ mit $h(x, i) = (x + 2i) \mod 9$:
  \begin{tabular}{c|c|c|c|c|c|c|c|c}
    0 & 1 & 2 & 3  & 4  & 5 & 6  & 7  & 8 \\
    \hline
    0 &   & 7 & 12 & 13 &   & 24 & 16 &   \\
  \end{tabular}
  \begin{enumerate}
    \item Nennen und beschreiben Sie die Ihnen aus der Vorlesung bekannten Strategien zur Kollisionsauflösung.
    \item Betrachten Sie eine (andere) Hashtabelle mit 1000 Einträgen. Welche der folgenden Hashfunktionen ist am geeignetsten für offene Adressierung? Begründen Sie Ihre Antwort!
          \begin{align*}
            h_1(x, i) & = (x + 5i) \mod 1000  \\
            h_2(x, i) & = (x + 17i) \mod 1000 \\
            h_3(x, i) & = (x + 32i) \mod 1000
          \end{align*}
    \item Führen Sie nacheinander aus und stellen Sie jeweils den Inhalt von $T$ dar:
          \begin{itemize}
            \item $\text{insert}(21)$
            \item $\text{insert}(95)$
            \item $\text{delete}(12)$
            \item $\text{delete}(21)$
            \item $\text{delete}(95)$
          \end{itemize}
    \item Definieren Sie den Begriff (Min-)Heap.
    \item Geben Sie einen Algorithmus an, der in $\bigO(n)$ Zeit einen binären Suchbaum in einen MinHeap umwandelt. Begründen Sie seine Korrektheit.
  \end{enumerate}
\end{exercise}

\begin{exercise}{Dynamische Programmierung}
  Die PERRIN-Folge kann wie dargestellt rekursiv berechnet werden:
  \begin{algorithm}[ht]
    \caption{PERRIN($n$)}
    \KwData{$n \in \mathbb{N}$}
    \KwResult{$\text{result} \in \mathbb{N}$}
    \If{$n = 0$}{
      \Return{3}
    }
    \If{$n = 1$}{
      \Return{0}
    }
    \If{$n = 2$}{
      \Return{2}
    }
    \Return{PERRIN($n-2$) + PERRIN($n-3$)}
  \end{algorithm}
  \begin{enumerate}
    \item Stellen Sie für die angegebene Funktion die Rekurrenzformel auf. Vereinfachen Sie, sodass Sie zeigen können, dass die obere und untere Schranke exponentiell wachsen.
    \item Erklären Sie, warum die angegebene Funktion nicht effizient ist und erläutern Sie die Entwicklungsschritte bei der Anwendung dynamischer Programmierung.
    \item Begründen Sie, weshalb für die gegebene Funktion dynamische Programmierung anwendbar ist.
    \item Spezifizieren Sie einen effizienteren Algorithmus zur Berechnung der PERRIN-Funktion unter Verwendung dynamischer Programmierung und nennen Sie seine Zeitkomplexität.
          \hint{2 Zusatzpunkte für einen Algorithmus mit $\bigO(1)$ Platzkomplexität}
  \end{enumerate}
\end{exercise}

\begin{exercise}{NP-Vollständigkeit}
  \begin{enumerate}
    \item Geben Sie die formalen Definitionen für P, NP an und erklären Sie die Begriffe NP-vollständig und NP-schwer.
    \item Erklären Sie kurz die Begriffe Zertifikatsfunktion \& Reduktion im Kontext der Prüfung auf NP-Vollständigkeit.
  \end{enumerate}
\end{exercise}
\end{document}